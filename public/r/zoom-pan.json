{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "zoom-pan",
  "title": "ZoomPan",
  "description": "A generic zoom and pan wrapper for any React content. Supports scroll-to-zoom, click-drag pan, and pinch-to-zoom.",
  "dependencies": [
    "lucide-react"
  ],
  "files": [
    {
      "path": "components/zoom-pan.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Loader2 } from \"lucide-react\";\n\nexport interface ZoomPanState {\n  scale: number;\n  translateX: number;\n  translateY: number;\n  /**\n   * If true, disables CSS transitions for immediate updates (e.g., during wheel/drag).\n   * If false, enables transitions for smooth steps (e.g., zoom buttons).\n   */\n  isImmediate: boolean;\n}\n\nexport interface ZoomPanProps {\n  /** Content to render inside the zoomable/pannable canvas */\n  children: React.ReactNode;\n  /** Optional className for the outer container */\n  className?: string;\n  /** Minimum zoom scale (default: 0.1) */\n  minScale?: number;\n  /** Maximum zoom scale (default: 5) */\n  maxScale?: number;\n  /** Initial zoom scale (default: 1) */\n  initialScale?: number;\n  /** Zoom step per scroll tick (default: 0.1) */\n  zoomStep?: number;\n  /** Render-prop for zoom controls UI */\n  controls?: (api: {\n    zoomIn: () => void;\n    zoomOut: () => void;\n    resetZoom: () => void;\n    centerView: () => void;\n    scalePercent: number;\n  }) => React.ReactNode;\n  isLoading?: boolean;\n  loadingFallback?: React.ReactNode;\n}\n\nexport function ZoomPan({\n  children,\n  className,\n  minScale = 0.1,\n  maxScale = 5,\n  initialScale = 1,\n  zoomStep = 0.1,\n  controls,\n  isLoading = false,\n  loadingFallback,\n}: ZoomPanProps) {\n  const containerRef = React.useRef<HTMLDivElement>(null);\n\n  const [zoomPan, setZoomPan] = React.useState<ZoomPanState>({\n    scale: initialScale,\n    translateX: 0,\n    translateY: 0,\n    isImmediate: false,\n  });\n\n  // Refs for gesture handling\n  const [isDragging, setIsDragging] = React.useState(false);\n  const panStartRef = React.useRef({ x: 0, y: 0 });\n  const lastTranslateRef = React.useRef({ x: 0, y: 0 });\n\n  // Momentum refs\n  const velocityRef = React.useRef({ x: 0, y: 0 });\n  const lastTimeRef = React.useRef(0);\n  const rafRef = React.useRef<number>(null);\n\n  const touchStartRef = React.useRef<{\n    touches: { x: number; y: number }[];\n    distance: number;\n    center: { x: number; y: number };\n    scale: number;\n    translateX: number;\n    translateY: number;\n  } | null>(null);\n\n  // Keep state in ref for event handlers\n  const zoomPanRef = React.useRef(zoomPan);\n  React.useEffect(() => {\n    zoomPanRef.current = zoomPan;\n  }, [zoomPan]);\n\n  // -- Momentum Panning Logic --\n\n  const startMomentum = () => {\n    if (rafRef.current) cancelAnimationFrame(rafRef.current);\n\n    const step = () => {\n      const { x: vx, y: vy } = velocityRef.current;\n      if (Math.abs(vx) < 0.05 && Math.abs(vy) < 0.05) {\n        return; // Stop when velocity is low\n      }\n\n      setZoomPan((prev) => ({\n        ...prev,\n        translateX: prev.translateX + vx,\n        translateY: prev.translateY + vy,\n        isImmediate: true,\n      }));\n\n      // Friction\n      velocityRef.current = { x: vx * 0.95, y: vy * 0.95 };\n      rafRef.current = requestAnimationFrame(step);\n    };\n\n    rafRef.current = requestAnimationFrame(step);\n  };\n\n  const stopMomentum = () => {\n    if (rafRef.current) {\n      cancelAnimationFrame(rafRef.current);\n      rafRef.current = null;\n    }\n    velocityRef.current = { x: 0, y: 0 };\n  };\n\n  // -- Zoom Control Helpers (Center Zoom) --\n\n  const getContainerCenter = () => {\n    if (!containerRef.current) return { x: 0, y: 0 };\n    const rect = containerRef.current.getBoundingClientRect();\n    return { x: rect.width / 2, y: rect.height / 2 };\n  };\n\n  const applyZoomToPoint = (delta: number, point: { x: number; y: number }) => {\n    stopMomentum();\n    setZoomPan((prev) => {\n      const newScale = Math.min(\n        maxScale,\n        Math.max(minScale, prev.scale + delta),\n      );\n      const ratio = newScale / prev.scale;\n\n      // Zoom around the point (relative to container)\n      const newTranslateX = point.x - (point.x - prev.translateX) * ratio;\n      const newTranslateY = point.y - (point.y - prev.translateY) * ratio;\n\n      return {\n        scale: newScale,\n        translateX: newTranslateX,\n        translateY: newTranslateY,\n        isImmediate: false, // Smooth transition for buttons\n      };\n    });\n  };\n\n  const zoomIn = React.useCallback(() => {\n    applyZoomToPoint(zoomStep, getContainerCenter());\n  }, [maxScale, zoomStep]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const zoomOut = React.useCallback(() => {\n    applyZoomToPoint(-zoomStep, getContainerCenter());\n  }, [minScale, zoomStep]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const resetZoom = React.useCallback(() => {\n    stopMomentum();\n    setZoomPan({\n      scale: initialScale,\n      translateX: 0,\n      translateY: 0,\n      isImmediate: false, // Smooth return to center\n    });\n  }, [initialScale]);\n\n  const centerView = React.useCallback(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Use the first child as the content to center\n    const content = container.firstElementChild as HTMLElement;\n    if (!content) return;\n\n    const contentWidth = content.scrollWidth;\n    const contentHeight = content.scrollHeight;\n    const containerWidth = container.clientWidth;\n    const containerHeight = container.clientHeight;\n\n    if (contentWidth === 0 || contentHeight === 0) return;\n\n    // Calculate scale to fit with padding\n    const padding = 40;\n    const availableWidth = containerWidth - padding;\n    const availableHeight = containerHeight - padding;\n\n    const scaleX = availableWidth / contentWidth;\n    const scaleY = availableHeight / contentHeight;\n    const fitScale = Math.min(\n      maxScale,\n      Math.max(minScale, Math.min(scaleX, scaleY)),\n    );\n\n    // Calculate center\n    const newTranslateX = (containerWidth - contentWidth * fitScale) / 2;\n    const newTranslateY = (containerHeight - contentHeight * fitScale) / 2;\n\n    stopMomentum();\n    setZoomPan({\n      scale: fitScale,\n      translateX: newTranslateX,\n      translateY: newTranslateY,\n      isImmediate: false,\n    });\n  }, [maxScale, minScale]);\n\n  const scalePercent = Math.round(zoomPan.scale * 100);\n\n  // -- Mouse Panning (Window-level listeners) --\n\n  React.useEffect(() => {\n    if (!isDragging) return;\n\n    const handleWindowMouseMove = (e: MouseEvent) => {\n      e.preventDefault();\n      const now = performance.now();\n      const dt = now - lastTimeRef.current;\n      lastTimeRef.current = now;\n\n      const dx = e.clientX - panStartRef.current.x;\n      const dy = e.clientY - panStartRef.current.y;\n\n      // Calculate velocity for momentum (pixels per frame approx)\n      if (dt > 0) {\n        velocityRef.current = {\n          x: e.movementX,\n          y: e.movementY,\n        };\n      }\n\n      setZoomPan((prev) => ({\n        ...prev,\n        translateX: lastTranslateRef.current.x + dx,\n        translateY: lastTranslateRef.current.y + dy,\n        isImmediate: true,\n      }));\n    };\n\n    const handleWindowMouseUp = () => {\n      setIsDragging(false);\n      startMomentum();\n    };\n\n    window.addEventListener(\"mousemove\", handleWindowMouseMove);\n    window.addEventListener(\"mouseup\", handleWindowMouseUp);\n\n    return () => {\n      window.removeEventListener(\"mousemove\", handleWindowMouseMove);\n      window.removeEventListener(\"mouseup\", handleWindowMouseUp);\n    };\n  }, [isDragging]);\n\n  const handleMouseDown = React.useCallback(\n    (e: React.MouseEvent<HTMLDivElement>) => {\n      // Middle or Left click only\n      if (isLoading) return;\n      if (e.button !== 0 && e.button !== 1) return;\n\n      e.preventDefault();\n      stopMomentum(); // Stop any existing coasting\n      setIsDragging(true);\n      panStartRef.current = { x: e.clientX, y: e.clientY };\n      lastTranslateRef.current = {\n        x: zoomPanRef.current.translateX,\n        y: zoomPanRef.current.translateY,\n      };\n      lastTimeRef.current = performance.now();\n      velocityRef.current = { x: 0, y: 0 };\n\n      // Immediate mode for dragging\n      setZoomPan((prev) => ({ ...prev, isImmediate: true }));\n    },\n    [isLoading],\n  );\n\n  // -- Touch Handling --\n\n  const getTouchDistance = (touches: TouchList) => {\n    if (touches.length < 2) return 0;\n    const dx = touches[0].clientX - touches[1].clientX;\n    const dy = touches[0].clientY - touches[1].clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  const getTouchCenter = (touches: TouchList) => {\n    if (touches.length < 2) return { x: 0, y: 0 };\n    return {\n      x: (touches[0].clientX + touches[1].clientX) / 2,\n      y: (touches[0].clientY + touches[1].clientY) / 2,\n    };\n  };\n\n  React.useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    if (isLoading) return;\n\n    const onWheel = (e: WheelEvent) => {\n      e.preventDefault();\n      stopMomentum();\n\n      const rect = container.getBoundingClientRect();\n      // Mouse position relative to container\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      setZoomPan((prev) => {\n        // Normalize wheel delta for consistent zoom across devices\n        // For standard mouse wheel, deltaY is usually around +/- 100\n        // For trackpads, it can be small float values.\n        let delta = e.deltaY;\n        if (e.deltaMode === 1) delta *= 40; // Line mode\n        if (e.deltaMode === 2) delta *= 800; // Page mode\n\n        const ZOOM_SENSITIVITY = 0.002;\n        const scaleFactor = Math.exp(-delta * ZOOM_SENSITIVITY);\n\n        const newScale = Math.min(\n          maxScale,\n          Math.max(minScale, prev.scale * scaleFactor),\n        );\n\n        // Calculate new translation to zoom towards mouse pointer\n        const ratio = newScale / prev.scale;\n        const newTranslateX = mouseX - (mouseX - prev.translateX) * ratio;\n        const newTranslateY = mouseY - (mouseY - prev.translateY) * ratio;\n\n        return {\n          scale: newScale,\n          translateX: newTranslateX,\n          translateY: newTranslateY,\n          isImmediate: true,\n        };\n      });\n    };\n\n    const onTouchStart = (e: TouchEvent) => {\n      stopMomentum();\n      const zp = zoomPanRef.current;\n\n      // Single touch - Pan\n      if (e.touches.length === 1) {\n        touchStartRef.current = {\n          touches: [{ x: e.touches[0].clientX, y: e.touches[0].clientY }],\n          distance: 0,\n          center: { x: 0, y: 0 },\n          scale: zp.scale,\n          translateX: zp.translateX,\n          translateY: zp.translateY,\n        };\n      }\n      // Multi touch - Pinch Zoom\n      else if (e.touches.length === 2) {\n        e.preventDefault();\n        const center = getTouchCenter(e.touches);\n\n        touchStartRef.current = {\n          touches: [\n            { x: e.touches[0].clientX, y: e.touches[0].clientY },\n            { x: e.touches[1].clientX, y: e.touches[1].clientY },\n          ],\n          distance: getTouchDistance(e.touches),\n          center,\n          scale: zp.scale,\n          translateX: zp.translateX,\n          translateY: zp.translateY,\n        };\n      }\n      setZoomPan((prev) => ({ ...prev, isImmediate: true }));\n    };\n\n    const onTouchMove = (e: TouchEvent) => {\n      if (!touchStartRef.current) return;\n      const rect = container.getBoundingClientRect();\n\n      // Pan\n      if (\n        e.touches.length === 1 &&\n        touchStartRef.current.touches.length === 1\n      ) {\n        const dx = e.touches[0].clientX - touchStartRef.current.touches[0].x;\n        const dy = e.touches[0].clientY - touchStartRef.current.touches[0].y;\n        setZoomPan({\n          scale: touchStartRef.current.scale,\n          translateX: touchStartRef.current.translateX + dx,\n          translateY: touchStartRef.current.translateY + dy,\n          isImmediate: true,\n        });\n      }\n      // Pinch Zoom\n      else if (e.touches.length === 2 && touchStartRef.current.distance > 0) {\n        e.preventDefault();\n        const newDist = getTouchDistance(e.touches);\n        const newCenter = getTouchCenter(e.touches);\n\n        const scaleRatio = newDist / touchStartRef.current.distance;\n        const newScale = Math.min(\n          maxScale,\n          Math.max(minScale, touchStartRef.current.scale * scaleRatio),\n        );\n\n        // Calculate Translation\n        const oldScale = touchStartRef.current.scale;\n        const oldTranslateX = touchStartRef.current.translateX;\n        const oldTranslateY = touchStartRef.current.translateY;\n\n        const oldCenterXRel = touchStartRef.current.center.x - rect.left;\n        const oldCenterYRel = touchStartRef.current.center.y - rect.top;\n\n        const newCenterXRel = newCenter.x - rect.left;\n        const newCenterYRel = newCenter.y - rect.top;\n\n        // Point on content\n        const contentX = (oldCenterXRel - oldTranslateX) / oldScale;\n        const contentY = (oldCenterYRel - oldTranslateY) / oldScale;\n\n        const newTranslateX = newCenterXRel - contentX * newScale;\n        const newTranslateY = newCenterYRel - contentY * newScale;\n\n        setZoomPan({\n          scale: newScale,\n          translateX: newTranslateX,\n          translateY: newTranslateY,\n          isImmediate: true,\n        });\n      }\n    };\n\n    const onTouchEnd = () => {\n      touchStartRef.current = null;\n    };\n\n    container.addEventListener(\"wheel\", onWheel, { passive: false });\n    container.addEventListener(\"touchstart\", onTouchStart, { passive: false });\n    container.addEventListener(\"touchmove\", onTouchMove, { passive: false });\n    container.addEventListener(\"touchend\", onTouchEnd);\n    container.addEventListener(\"touchcancel\", onTouchEnd);\n\n    return () => {\n      container.removeEventListener(\"wheel\", onWheel);\n      container.removeEventListener(\"touchstart\", onTouchStart);\n      container.removeEventListener(\"touchmove\", onTouchMove);\n      container.removeEventListener(\"touchend\", onTouchEnd);\n      container.removeEventListener(\"touchcancel\", onTouchEnd);\n    };\n  }, [minScale, maxScale, zoomStep, isLoading]);\n\n  return (\n    <div className={cn(\"flex flex-col\", className)}>\n      {/* eslint-disable-next-line react-hooks/refs */}\n      {controls?.({ zoomIn, zoomOut, resetZoom, centerView, scalePercent })}\n      <div\n        ref={containerRef}\n        className=\"relative min-h-0 flex-1 cursor-grab overflow-hidden active:cursor-grabbing\"\n        onMouseDown={handleMouseDown}\n      >\n        <div\n          style={{\n            transform: `translate(${zoomPan.translateX}px, ${zoomPan.translateY}px) scale(${zoomPan.scale})`,\n            transformOrigin: \"0 0\",\n            willChange: \"transform\",\n            transition: zoomPan.isImmediate\n              ? \"none\"\n              : \"transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)\",\n          }}\n          className=\"inline-flex origin-top-left [&_svg]:max-w-full\"\n        >\n          {children}\n        </div>\n        {isLoading && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-background/50 z-50\">\n            {loadingFallback || (\n              <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\n/** Standalone hook for custom zoom/pan implementations */\nexport function useZoomPan(initialScale = 1) {\n  const [zoomPan, setZoomPan] = React.useState<ZoomPanState>({\n    scale: initialScale,\n    translateX: 0,\n    translateY: 0,\n    isImmediate: false,\n  });\n\n  const zoomIn = React.useCallback(() => {\n    setZoomPan((prev) => ({\n      ...prev,\n      scale: Math.min(5, prev.scale + 0.1),\n      isImmediate: false,\n    }));\n  }, []);\n\n  const zoomOut = React.useCallback(() => {\n    setZoomPan((prev) => ({\n      ...prev,\n      scale: Math.max(0.1, prev.scale - 0.1),\n      isImmediate: false,\n    }));\n  }, []);\n\n  const resetZoom = React.useCallback(() => {\n    setZoomPan({\n      scale: initialScale,\n      translateX: 0,\n      translateY: 0,\n      isImmediate: false,\n    });\n  }, [initialScale]);\n\n  return {\n    zoomPan,\n    setZoomPan,\n    zoomIn,\n    zoomOut,\n    resetZoom,\n    scalePercent: Math.round(zoomPan.scale * 100),\n  };\n}\n",
      "type": "registry:component",
      "target": "components/mermaidcn/zoom-pan.tsx"
    }
  ],
  "type": "registry:component"
}