{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "zoom-pan",
  "title": "ZoomPan",
  "description": "A generic zoom and pan wrapper for any React content. Supports scroll-to-zoom, click-drag pan, and pinch-to-zoom.",
  "dependencies": [
    "lucide-react"
  ],
  "files": [
    {
      "path": "components/zoom-pan.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Loader2 } from \"lucide-react\";\n\nexport interface ZoomPanState {\n  scale: number;\n  translateX: number;\n  translateY: number;\n  isImmediate: boolean;\n}\n\nexport interface ZoomPanProps {\n  children: React.ReactNode;\n  className?: string;\n  minScale?: number;\n  maxScale?: number;\n  initialScale?: number;\n  zoomStep?: number;\n  controls?: (api: {\n    zoomIn: () => void;\n    zoomOut: () => void;\n    resetZoom: () => void;\n    centerView: () => void;\n    scalePercent: number;\n  }) => React.ReactNode;\n  isLoading?: boolean;\n  loadingFallback?: React.ReactNode;\n}\n\nexport function ZoomPan({\n  children,\n  className,\n  minScale = 0.1,\n  maxScale = 5,\n  initialScale = 1,\n  zoomStep = 0.1,\n  controls,\n  isLoading = false,\n  loadingFallback,\n}: ZoomPanProps) {\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const contentRef = React.useRef<HTMLDivElement>(null);\n\n  // -- State --\n  // We keep React state for the \"committed\" values (for UI controls).\n  // During gestures, we bypass this and update the DOM directly.\n  const [zoomPan, setZoomPan] = React.useState<ZoomPanState>({\n    scale: initialScale,\n    translateX: 0,\n    translateY: 0,\n    isImmediate: false,\n  });\n\n  // -- Refs for High-Perf Updates --\n  // currentRef: The actual value currently applied to the DOM\n  const currentRef = React.useRef({\n    scale: initialScale,\n    x: 0,\n    y: 0,\n  });\n\n  // targetRef: Where the user wants to go (updated by gestures/buttons)\n  const targetRef = React.useRef({\n    scale: initialScale,\n    x: 0,\n    y: 0,\n  });\n\n  const isDragging = React.useRef(false);\n  const isPinching = React.useRef(false);\n  const panStartRef = React.useRef({ x: 0, y: 0 });\n  const targetStartRef = React.useRef({ x: 0, y: 0 });\n\n  // Momentum\n  const velocityRef = React.useRef({ x: 0, y: 0 });\n  const lastTimeRef = React.useRef(0);\n  const lastInteractionTimeRef = React.useRef({ x: 0, y: 0 });\n  const rafRef = React.useRef<number | null>(null);\n\n  // Touch\n  const touchStartRef = React.useRef<{\n    touches: { x: number; y: number }[];\n    distance: number;\n    center: { x: number; y: number };\n    scale: number;\n    translateX: number;\n    translateY: number;\n  } | null>(null);\n\n  // -- Physics / Animation Loop --\n\n  // Sync DOM directly from currentRef\n  const updateDom = React.useCallback((isImmediate = true) => {\n    if (!contentRef.current) return;\n    const { x, y, scale } = currentRef.current;\n\n    contentRef.current.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;\n    contentRef.current.style.transition = isImmediate\n      ? \"none\"\n      : \"transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)\";\n  }, []);\n\n  // Sync CurrentRef -> State (For UI controls)\n  const commitToState = React.useCallback(() => {\n    setZoomPan((prev) => ({\n      scale: currentRef.current.scale,\n      translateX: currentRef.current.x,\n      translateY: currentRef.current.y,\n      isImmediate: prev.isImmediate, // Keep whatever transition mode we were in\n    }));\n  }, []);\n\n  const startAnimation = React.useCallback(() => {\n    if (rafRef.current) return;\n\n    const step = () => {\n      const target = targetRef.current;\n      const current = currentRef.current;\n      const velocity = velocityRef.current;\n\n      // 1. Apply Momentum if not dragging\n      if (!isDragging.current && !isPinching.current) {\n        if (Math.abs(velocity.x) > 0.01 || Math.abs(velocity.y) > 0.01) {\n          target.x += velocity.x;\n          target.y += velocity.y;\n          velocity.x *= 0.92; // Friction\n          velocity.y *= 0.92;\n        } else {\n          velocity.x = 0;\n          velocity.y = 0;\n        }\n      }\n\n      // 2. Interpolate (Lerp) actual towards target for \"Slow Easing\"\n      // Panning easing\n      const lerpPan = 0.1;\n      // Zoom easing\n      const lerpZoom = 0.06;\n\n      const dx = target.x - current.x;\n      const dy = target.y - current.y;\n      const ds = target.scale - current.scale;\n\n      current.x += dx * lerpPan;\n      current.y += dy * lerpPan;\n      current.scale += ds * lerpZoom;\n\n      updateDom(true);\n\n      // 3. Check if we should stop\n      const isStillMoving =\n        Math.abs(dx) > 0.1 ||\n        Math.abs(dy) > 0.1 ||\n        Math.abs(ds) > 0.001 ||\n        Math.abs(velocity.x) > 0.1 ||\n        Math.abs(velocity.y) > 0.1;\n\n      if (isStillMoving || isDragging.current || isPinching.current) {\n        rafRef.current = requestAnimationFrame(step);\n      } else {\n        rafRef.current = null;\n        commitToState();\n      }\n    };\n\n    rafRef.current = requestAnimationFrame(step);\n  }, [updateDom, commitToState]);\n\n  React.useEffect(() => {\n    targetRef.current = {\n      scale: zoomPan.scale,\n      x: zoomPan.translateX,\n      y: zoomPan.translateY,\n    };\n\n    if (zoomPan.isImmediate) {\n      // For gestures, the loop is already running or will be started\n      startAnimation();\n    } else {\n      // For buttons, use CSS transitions for consistency, but sync internal Refs\n      currentRef.current = { ...targetRef.current };\n      updateDom(false);\n    }\n  }, [zoomPan, updateDom, startAnimation]);\n\n  // -- Zoom Controls (Button based) --\n\n  const getContainerCenter = React.useCallback(() => {\n    if (!containerRef.current) return { x: 0, y: 0 };\n    const rect = containerRef.current.getBoundingClientRect();\n    return { x: rect.width / 2, y: rect.height / 2 };\n  }, []);\n\n  const applyZoomToPoint = React.useCallback(\n    (delta: number, point: { x: number; y: number }) => {\n      const prevScale = zoomPan.scale;\n      const prevX = zoomPan.translateX;\n      const prevY = zoomPan.translateY;\n\n      const newScale = Math.min(\n        maxScale,\n        Math.max(minScale, prevScale + delta),\n      );\n      const ratio = newScale / prevScale;\n\n      const newX = point.x - (point.x - prevX) * ratio;\n      const newY = point.y - (point.y - prevY) * ratio;\n\n      // Update via React state to trigger smooth transition\n      setZoomPan({\n        scale: newScale,\n        translateX: newX,\n        translateY: newY,\n        isImmediate: false,\n      });\n    },\n    [maxScale, minScale, zoomPan.scale, zoomPan.translateX, zoomPan.translateY],\n  );\n\n  const zoomIn = React.useCallback(() => {\n    applyZoomToPoint(zoomStep, getContainerCenter());\n  }, [zoomStep, applyZoomToPoint, getContainerCenter]);\n\n  const zoomOut = React.useCallback(() => {\n    applyZoomToPoint(-zoomStep, getContainerCenter());\n  }, [zoomStep, applyZoomToPoint, getContainerCenter]);\n\n  const resetZoom = React.useCallback(() => {\n    setZoomPan({\n      scale: initialScale,\n      translateX: 0,\n      translateY: 0,\n      isImmediate: false,\n    });\n  }, [initialScale]);\n\n  const centerView = React.useCallback(() => {\n    const container = containerRef.current;\n    const content = contentRef.current;\n    if (!container || !content) return;\n\n    const contentRect = content.getBoundingClientRect();\n    // Unscaled dimensions\n    const currentScale = zoomPan.scale;\n    const contentWidth = contentRect.width / currentScale;\n    const contentHeight = contentRect.height / currentScale;\n\n    const containerWidth = container.clientWidth;\n    const containerHeight = container.clientHeight;\n\n    if (contentWidth === 0 || contentHeight === 0) return;\n\n    const padding = 40;\n    const availableWidth = containerWidth - padding;\n    const availableHeight = containerHeight - padding;\n\n    const scaleX = availableWidth / contentWidth;\n    const scaleY = availableHeight / contentHeight;\n    const fitScale = Math.min(\n      maxScale,\n      Math.max(minScale, Math.min(scaleX, scaleY)),\n    );\n\n    const newX = (containerWidth - contentWidth * fitScale) / 2;\n    const newY = (containerHeight - contentHeight * fitScale) / 2;\n\n    setZoomPan({\n      scale: fitScale,\n      translateX: newX,\n      translateY: newY,\n      isImmediate: false,\n    });\n  }, [maxScale, minScale, zoomPan.scale]);\n\n  // -- Mouse Panning --\n\n  React.useEffect(() => {\n    const handleWindowMouseMove = (e: MouseEvent) => {\n      if (!isDragging.current || isPinching.current) return;\n      e.preventDefault();\n\n      const now = performance.now();\n      const dt = now - lastTimeRef.current;\n\n      const dx = e.clientX - panStartRef.current.x;\n      const dy = e.clientY - panStartRef.current.y;\n\n      if (dt > 0) {\n        velocityRef.current = {\n          x: e.clientX - lastInteractionTimeRef.current.x || 0,\n          y: e.clientY - lastInteractionTimeRef.current.y || 0,\n        };\n      }\n\n      targetRef.current.x = targetStartRef.current.x + dx;\n      targetRef.current.y = targetStartRef.current.y + dy;\n\n      lastTimeRef.current = now;\n      lastInteractionTimeRef.current = { x: e.clientX, y: e.clientY };\n      startAnimation();\n    };\n\n    const handleWindowMouseUp = () => {\n      if (isDragging.current) {\n        isDragging.current = false;\n      }\n    };\n\n    window.addEventListener(\"mousemove\", handleWindowMouseMove);\n    window.addEventListener(\"mouseup\", handleWindowMouseUp);\n    return () => {\n      window.removeEventListener(\"mousemove\", handleWindowMouseMove);\n      window.removeEventListener(\"mouseup\", handleWindowMouseUp);\n    };\n  }, [updateDom, startAnimation]);\n\n  const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {\n    if (isLoading || (e.button !== 0 && e.button !== 1)) return;\n\n    e.preventDefault();\n    isDragging.current = true;\n    panStartRef.current = { x: e.clientX, y: e.clientY };\n    targetStartRef.current = {\n      x: targetRef.current.x,\n      y: targetRef.current.y,\n    };\n    lastTimeRef.current = performance.now();\n    lastInteractionTimeRef.current = { x: e.clientX, y: e.clientY };\n    velocityRef.current = { x: 0, y: 0 };\n    startAnimation();\n  };\n\n  const getTouchDistance = (touches: TouchList) => {\n    if (touches.length < 2) return 0;\n    const dx = touches[0].clientX - touches[1].clientX;\n    const dy = touches[0].clientY - touches[1].clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  const getTouchCenter = (touches: TouchList) => {\n    if (touches.length < 2) return { x: 0, y: 0 };\n    return {\n      x: (touches[0].clientX + touches[1].clientX) / 2,\n      y: (touches[0].clientY + touches[1].clientY) / 2,\n    };\n  };\n\n  React.useEffect(() => {\n    const container = containerRef.current;\n    if (!container || isLoading) return;\n\n    const onWheel = (e: WheelEvent) => {\n      e.preventDefault();\n\n      const rect = container.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      let delta = e.deltaY;\n      if (e.deltaMode === 1) delta *= 40;\n      if (e.deltaMode === 2) delta *= 800;\n\n      const ZOOM_SENSITIVITY = 0.002;\n      const scaleFactor = Math.exp(-delta * ZOOM_SENSITIVITY);\n\n      const target = targetRef.current;\n      const newScale = Math.min(\n        maxScale,\n        Math.max(minScale, target.scale * scaleFactor),\n      );\n\n      const ratio = newScale / target.scale;\n      target.x = mouseX - (mouseX - target.x) * ratio;\n      target.y = mouseY - (mouseY - target.y) * ratio;\n      target.scale = newScale;\n\n      startAnimation();\n    };\n\n    const onTouchStart = (e: TouchEvent) => {\n      const { x, y, scale } = targetRef.current;\n\n      if (e.touches.length === 1) {\n        isDragging.current = true;\n        isPinching.current = false;\n        touchStartRef.current = {\n          touches: [{ x: e.touches[0].clientX, y: e.touches[0].clientY }],\n          distance: 0,\n          center: { x: 0, y: 0 },\n          scale,\n          translateX: x,\n          translateY: y,\n        };\n      } else if (e.touches.length === 2) {\n        isDragging.current = false;\n        isPinching.current = true;\n        const center = getTouchCenter(e.touches);\n        touchStartRef.current = {\n          touches: [\n            { x: e.touches[0].clientX, y: e.touches[0].clientY },\n            { x: e.touches[1].clientX, y: e.touches[1].clientY },\n          ],\n          distance: getTouchDistance(e.touches),\n          center,\n          scale,\n          translateX: x,\n          translateY: y,\n        };\n      }\n      lastTimeRef.current = performance.now();\n      lastInteractionTimeRef.current = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY,\n      };\n      velocityRef.current = { x: 0, y: 0 };\n      startAnimation();\n    };\n\n    const onTouchMove = (e: TouchEvent) => {\n      // PREVENT BODY SCROLLING:\n      if (e.cancelable) e.preventDefault();\n\n      if (!touchStartRef.current) return;\n\n      const now = performance.now();\n      const dt = now - lastTimeRef.current;\n\n      if (\n        e.touches.length === 1 &&\n        touchStartRef.current.touches.length === 1\n      ) {\n        const dx = e.touches[0].clientX - touchStartRef.current.touches[0].x;\n        const dy = e.touches[0].clientY - touchStartRef.current.touches[0].y;\n\n        if (dt > 0) {\n          velocityRef.current = {\n            x: e.touches[0].clientX - lastInteractionTimeRef.current.x || 0,\n            y: e.touches[0].clientY - lastInteractionTimeRef.current.y || 0,\n          };\n        }\n\n        targetRef.current.x = touchStartRef.current.translateX + dx;\n        targetRef.current.y = touchStartRef.current.translateY + dy;\n\n        lastInteractionTimeRef.current = {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY,\n        };\n      }\n      // Pinch\n      else if (e.touches.length === 2 && touchStartRef.current.distance > 0) {\n        const newDist = getTouchDistance(e.touches);\n        const newCenter = getTouchCenter(e.touches);\n        const rect = container.getBoundingClientRect();\n\n        const scaleRatio = newDist / touchStartRef.current.distance;\n        const newScale = Math.min(\n          maxScale,\n          Math.max(minScale, touchStartRef.current.scale * scaleRatio),\n        );\n\n        const oldScale = touchStartRef.current.scale;\n        const oldX = touchStartRef.current.translateX;\n        const oldY = touchStartRef.current.translateY;\n\n        const oldCenterRelX = touchStartRef.current.center.x - rect.left;\n        const oldCenterRelY = touchStartRef.current.center.y - rect.top;\n        const newCenterRelX = newCenter.x - rect.left;\n        const newCenterRelY = newCenter.y - rect.top;\n\n        const contentX = (oldCenterRelX - oldX) / oldScale;\n        const contentY = (oldCenterRelY - oldY) / oldScale;\n\n        targetRef.current.scale = newScale;\n        targetRef.current.x = newCenterRelX - contentX * newScale;\n        targetRef.current.y = newCenterRelY - contentY * newScale;\n      }\n\n      lastTimeRef.current = now;\n    };\n\n    const onTouchEnd = () => {\n      isDragging.current = false;\n      isPinching.current = false;\n      touchStartRef.current = null;\n    };\n\n    container.addEventListener(\"wheel\", onWheel, { passive: false });\n    container.addEventListener(\"touchstart\", onTouchStart, { passive: false });\n    container.addEventListener(\"touchmove\", onTouchMove, { passive: false });\n    container.addEventListener(\"touchend\", onTouchEnd);\n    container.addEventListener(\"touchcancel\", onTouchEnd);\n\n    return () => {\n      container.removeEventListener(\"wheel\", onWheel);\n      container.removeEventListener(\"touchstart\", onTouchStart);\n      container.removeEventListener(\"touchmove\", onTouchMove);\n      container.removeEventListener(\"touchend\", onTouchEnd);\n      container.removeEventListener(\"touchcancel\", onTouchEnd);\n    };\n  }, [minScale, maxScale, isLoading, updateDom, startAnimation, zoomPan]); // Added zoomPan to dependencies\n\n  const [api, setApi] = React.useState<{\n    zoomIn: () => void;\n    zoomOut: () => void;\n    resetZoom: () => void;\n    centerView: () => void;\n    scalePercent: number;\n  } | null>(null);\n\n  React.useLayoutEffect(() => {\n    setApi({\n      zoomIn: () => zoomIn(),\n      zoomOut: () => zoomOut(),\n      resetZoom: () => resetZoom(),\n      centerView: () => centerView(),\n      scalePercent: Math.round(zoomPan.scale * 100),\n    });\n  }, [zoomIn, zoomOut, resetZoom, centerView, zoomPan.scale]);\n\n  return (\n    <div className={cn(\"flex flex-col\", className)}>\n      {controls && api && controls(api)}\n\n      <div\n        ref={containerRef}\n        className=\"relative min-h-0 flex-1 cursor-grab overflow-hidden active:cursor-grabbing touch-none select-none\"\n        onMouseDown={handleMouseDown}\n      >\n        <div\n          ref={contentRef}\n          style={{\n            transform: `translate(${zoomPan.translateX}px, ${zoomPan.translateY}px) scale(${zoomPan.scale})`,\n            transformOrigin: \"0 0\",\n            willChange: \"transform\",\n            transition: zoomPan.isImmediate\n              ? \"none\"\n              : \"transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)\",\n          }}\n          className=\"inline-flex origin-top-left [&_svg]:max-w-full\"\n        >\n          {children}\n        </div>\n        {isLoading && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-background/50 z-50\">\n            {loadingFallback || (\n              <Loader2 className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/mermaidcn/zoom-pan.tsx"
    }
  ],
  "type": "registry:component"
}